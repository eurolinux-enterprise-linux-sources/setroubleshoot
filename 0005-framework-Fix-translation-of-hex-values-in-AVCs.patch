From 1f8ab12a770f0b84e397a40abc3d0cd67c99958d Mon Sep 17 00:00:00 2001
From: Vit Mojzis <vmojzis@redhat.com>
Date: Wed, 13 Feb 2019 10:31:15 +0100
Subject: [PATCH 5/7] framework: Fix translation of hex values in AVCs

Audit encloses plain text values of path, name or exe fields in double
quotes to distinguish them from hex encoded values. Use this instead of
trying to hex-translate all values. The translation is done immediately
after parsing the AVC, hence all other attempts to hex translate could
be removed.

Use bytearray.fromhex(path).decode('utf-8') in python 3
(str.decode('hex') is invalid).
Keep using str.decode('hex') on python 2 to avoid issues with unicode
strings (which are not accepted by libselinux functions).

Fixes:
   https://bugzilla.redhat.com/show_bug.cgi?id=1477236

Signed-off-by: Vit Mojzis <vmojzis@redhat.com>
---
 framework/src/setroubleshoot/audit_data.py | 74 ++++++----------------
 framework/src/setroubleshoot/util.py       | 11 +++-
 2 files changed, 30 insertions(+), 55 deletions(-)

diff --git a/framework/src/setroubleshoot/audit_data.py b/framework/src/setroubleshoot/audit_data.py
index 8b65915..c0aabb1 100644
--- a/framework/src/setroubleshoot/audit_data.py
+++ b/framework/src/setroubleshoot/audit_data.py
@@ -37,6 +37,7 @@ import selinux
 import base64
 from types import *
 import selinux.audit2why as audit2why
+import sys
 
 from setroubleshoot.util import *
 from setroubleshoot.html_util import *
@@ -308,24 +309,22 @@ class AuditRecord(XmlSerialize):
 		    value = self.fields[field]
 		    decoded_value = audit_msg_decode(value)
 		    self.fields[field] = decoded_value
-		    
-		
-    def translate_path(self, path):
+
+
+    def translate_hex(self, path):
         try:
-            t = path.decode("hex")
-            if t[0].encode("hex") == "00":
-                tpath = "@"
+            if sys.version_info[0] < 3:
+                # Produces normal string instead of unicode string which is not
+                # accepted by libselinux functions.
+                # This means that len(path) will return inaccurate results when
+                # the string contains special characters. Also individual bytes
+                # of path may not be printable.
+                return path.decode('hex')
             else:
-                tpath = t[0]
-
-            for i in range(len(t))[1:]:
-                if t[i].encode("hex") != "00":
-                    tpath = tpath + t[i]
-                else:
-                    break
+                # produces str in python 3 and unicode string in python 2
+                return bytearray.fromhex(path).decode('utf-8')
         except:
             return path
-        return tpath
 
     def set_fields_from_text(self, body_text):
         self.fields_ord = []
@@ -340,8 +339,10 @@ class AuditRecord(XmlSerialize):
                     i = audit.audit_elf_to_machine(int(value,16))
                     value = audit.audit_machine_to_name(i)
 
-                if key == "path":
-                    value = '"%s"' % self.translate_path(value)
+                if key in ["name", "path", "comm", "cmd", "exe", "cwd"]:
+                    # audit uses " to distinguish plain text from hex in listed keys
+                    if not match.group(2).startswith('"'):
+                        value = self.translate_hex(value)
 
                 if key == "exit":
                     try:
@@ -743,31 +744,6 @@ class AVC:
         if self.tpath is None: return True
         return self.tpath not in standard_directories
 
-    def decodehex(self,path):
-        try:
-            t = path.decode("hex")
-            if t[0].encode("hex") == "00":
-                tpath = "@"
-            else:
-                tpath = t[0]
-
-            for i in range(len(t))[1:]:
-                if t[i].encode("hex") != "00":
-                    tpath = tpath + t[i]
-                else:
-                    break
-
-            if not printable(tpath):
-                tpath = path
-
-        except:
-            tpath = path
-
-        if not printable(tpath):
-            return ""
-
-        return tpath
-
     def _set_tpath(self):
         '''Derive the target path.
 
@@ -803,8 +779,7 @@ class AVC:
         # versions put it there rather than in AVC_PATH
 
         path = self.avc_record.get_field('path')
-        if path:
-            path = path.strip('"')
+
         inodestr = self.avc_record.get_field("ino")
         if path is None:
             # No path field in AVC record, try to get path from PATH records
@@ -913,9 +888,7 @@ class AVC:
                 if match:
                     path = self.tclass
 
-        self.tpath = self.decodehex(path)
-        if self.tpath == '':
-            self.tpath = path
+        self.tpath = path
 
         if self.tpath is None:
             if self.tclass == "filesystem":
@@ -961,10 +934,6 @@ class AVC:
 
         if syscall_record:
             exe     = syscall_record.get_field('exe')
-            try:
-                exe.decode("hex")
-            except:
-                pass
             comm    = syscall_record.get_field('comm')
             self.syscall = syscall_record.get_field('syscall')
             self.success = (syscall_record.get_field('success') == "yes")
@@ -975,10 +944,7 @@ class AVC:
         if exe is None:
             exe = self.avc_record.get_field('exe')
 
-        try:
-            self.spath = exe.decode("hex")
-        except:
-            self.spath = exe
+        self.spath = exe
 
         if comm:
             self.source = comm
diff --git a/framework/src/setroubleshoot/util.py b/framework/src/setroubleshoot/util.py
index 40ecfb1..c62ee31 100755
--- a/framework/src/setroubleshoot/util.py
+++ b/framework/src/setroubleshoot/util.py
@@ -159,7 +159,16 @@ def audit_msg_decode(msg):
         decoded = match.group(1)
     else:
         try:
-            decoded = msg.decode('hex')
+            if sys.version_info[0] < 3:
+                # Produces normal string instead of unicode string which is not
+                # accepted by libselinux functions.
+                # This means that len(path) will return inaccurate results when
+                # the string contains special characters. Also individual bytes
+                # of path may not be printable.
+                decoded = msg.decode('hex')
+            else:
+                # produces str in python 3 and unicode string in python 2
+                decoded = bytearray.fromhex(msg).decode('utf-8')
         except:
             decoded = msg
     return decoded
-- 
2.17.2

